package net.fish.geometry.hex.projection

import net.fish.geometry.hex.Hex
import net.fish.geometry.hex.Orientation.ORIENTATION.FLAT
import net.fish.geometry.hex.Orientation.ORIENTATION.POINTY
import net.fish.geometry.hex.WrappingHexGrid
import net.fish.geometry.paths.PathCreator
import net.fish.geometry.paths.PathData
import org.joml.Vector3f
import kotlin.math.PI
import kotlin.math.cos
import kotlin.math.sin

// This will create the coordinates for any hexagon around the path generated by the given path creator.
// The hexGrid controls movement within the hexagons, but this class presents the real world coordinates of
// each hexagon mapped onto the given Torus Knot
data class PathMappedWrappingHexGrid(
    override val hexGrid: WrappingHexGrid,
    override val pathCreator: PathCreator,
    val r: Double = 0.2
) : SurfaceMapper(hexGrid, pathCreator) {
    private var hexCentres: Map<Hex, Vector3f> = emptyMap()

    override fun coordinates(hex: Hex): List<Vector3f> {
        if (hexCentres.isEmpty()) {
            hexCentres = calculateHexCentres()
        }

        val pairs = when (hexGrid.layout.orientation) {
            POINTY -> listOf(Pair(5, 0), Pair(0, 1), Pair(1, 2), Pair(2, 3), Pair(3, 4), Pair(4, 5))
            FLAT -> listOf(Pair(0, 1), Pair(1, 2), Pair(2, 3), Pair(3, 4), Pair(4, 5), Pair(5, 0))
        }
        // for a given hex, its corners are calculated relative to the hexes around it for simplicity
        val corners = pairs.map { neighbourPair ->
            averageCentres(hex, hex.neighbour(neighbourPair.first), hex.neighbour(neighbourPair.second))
        }

        return corners + hexCentres[hex]!!
    }

    private fun averageCentres(h0: Hex, h1: Hex, h2: Hex): Vector3f {
        val hc0 = hexCentres.getOrDefault(h0, Vector3f())
        val hc1 = hexCentres.getOrDefault(h1, Vector3f())
        val hc2 = hexCentres.getOrDefault(h2, Vector3f())
        return hc0.add(hc1, Vector3f()).add(hc2).div(3f)
    }

    private fun calculateHexCentres(): Map<Hex, Vector3f> {
        return when (hexGrid.layout.orientation) {
            POINTY -> calcuatePointyHexCentres()
            FLAT -> calculateFlatHexCentres()
        }

    }

    private fun calculateFlatHexCentres(): Map<Hex, Vector3f> {
        val centres = mutableMapOf<Hex, Vector3f>()
        val pathCoordinates = pathCreator.createPath(hexGrid.m)
        pathCoordinates.forEachIndexed { segment, knotData ->
            val hexList = mutableListOf<Hex>()
            val hq = segment
            val hs = -segment / 2
            val hr = -hq - hs
            var hexToAdd = hexGrid.hex(hq, hr, hs)
            hexList.add(hexToAdd)
            (0 until hexGrid.n).forEach { _ ->
                hexToAdd = hexToAdd.neighbour(2)
                hexList.add(hexToAdd)
            }
            hexList.forEachIndexed { index, hex ->
                val adjustOddHexes = if (segment % 2 == 0) 0.0 else (0.5 / hexGrid.n)
                val theta = 2.0 * PI * (1.0 / hexGrid.n * index + adjustOddHexes)
                centres[hex] = calculateHexCentre(knotData, theta)
            }

        }
        return centres
    }

    private fun calcuatePointyHexCentres(): Map<Hex, Vector3f> {
        val centres = mutableMapOf<Hex, Vector3f>()
        val pathCoordinates = pathCreator.createPath(hexGrid.m * 2)
        pathCoordinates.forEachIndexed { segment, pathData ->
            val hexList = mutableListOf<Hex>()
            var hexToAdd = when {
                segment % 2 == 0 -> {
                    val hq = segment / 2
                    val hr = 0
                    val hs = -hq
                    hexGrid.hex(hq, hr, hs)
                }
                else -> {
                    val hq = (segment + 1) / 2
                    val hr = -1
                    val hs = -hq - hr
                    hexGrid.hex(hq, hr, hs)
                }
            }
            hexList.add(hexToAdd)
            (0 until (hexGrid.n / 2 - 1)).forEach { _ ->
                hexToAdd = hexToAdd.diagonalNeighbour(1) // add the "north" diagonal
                hexList.add(hexToAdd)
            }
            hexList.forEachIndexed { index, hex ->
                // pencil and paper!
                val adjustOddHexes = if (segment % 2 == 0) 0.0 else (1.0 / hexGrid.n)
                val theta = 2.0 * PI * (2.0 / hexGrid.n * index + adjustOddHexes)
                centres[hex] = calculateHexCentre(pathData, theta)
            }
        }
        return centres
    }

    private fun calculateHexCentre(pathData: PathData, theta: Double): Vector3f {
        val b = pathData.tangent.cross(pathData.normal, Vector3f())
        val xd = b.mul((r * cos(theta)).toFloat(), Vector3f())
        val yd = pathData.normal.mul((r * sin(theta)).toFloat(), Vector3f())
        return xd.add(pathData.point).add(yd)
    }
}